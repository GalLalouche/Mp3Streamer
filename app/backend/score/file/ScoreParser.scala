package backend.score.file

import java.util.regex.Pattern

import backend.recon.{Album, Artist, Track}
import backend.score.{CachedModelScorer, OptionalModelScore}
import backend.score.file.ScoreParser.OrgPrefix
import backend.score.storage.{AlbumScoreStorage, ArtistScoreStorage, TrackScoreStorage}
import com.google.inject.Inject

import scala.concurrent.{ExecutionContext, Future}
import scala.util.Try

import common.rich.func.BetterFutureInstances._
import common.rich.func.MoreTraverseInstances._
import common.rich.func.ToMoreFunctorOps.toMoreFunctorOps
import common.rich.func.TuplePLenses
import scalaz.Scalaz.{optionInstance, ToBindOps, ToFunctorOpsUnapply, ToTraverseOpsUnapply, ToTuple2Ops}

import common.Trither
import common.rich.primitives.RichString._

/** Parses the .org file generated by [[MassScorer]]. */
private class ScoreParser @Inject() (
    artistScoreStorage: ArtistScoreStorage,
    albumScoreStorage: AlbumScoreStorage,
    trackScoreStorage: TrackScoreStorage,
    cachedModelScorer: CachedModelScorer,
    ec: ExecutionContext,
) {
  private implicit val iec: ExecutionContext = ec

  def parseLines(lines: Seq[String]): Future[Unit] = {
    val changes = lines.flatMap(parse)
    if (changes.isEmpty) {
      scribe.info("No score changes")
      return Future.successful(())
    }

    val (artists, albums, tracks) =
      Trither.partition(changes.view.map(_.fold(_.tritherStrengthenLeft(_))))
    // FIXME multiple overwrite void silently fails on foreign key error
    // This isn't very efficient, since we're performing each update as a separate statement, but
    // since we expect the number of changes to be relatively small, this should be fine.
    artists.traverse(Function.tupled(artistScoreStorage.updateScore)).void >>
      albums.traverse(Function.tupled(albumScoreStorage.updateScore)).void >>
      tracks.traverse(Function.tupled(trackScoreStorage.updateScore)).void
  }

  // Returns None if line isn't a score line, or if the score hasn't changed.
  private def parse(line: String): Option[(Trither[Artist, Album, Track], OptionalModelScore)] = {
    val withoutPrefix = line.removeAll(OrgPrefix)
    // TODO use the parser here as well, using either or something.
    val $ : Try[(Trither[Artist, Album, Track], OptionalModelScore)] =
      if (withoutPrefix.startsWith("ARTIST"))
        ArtistScoreParser(line).map(TuplePLenses.tuple2First.modify(Trither.TriLeft.apply))
      else if (withoutPrefix.startsWith("ALBUM"))
        AlbumScoreParser(line).map(TuplePLenses.tuple2First.modify(Trither.TriMid.apply))
      else if (withoutPrefix.startsWith("SONG"))
        TrackScoreParser(line).map(TuplePLenses.tuple2First.modify(Trither.TriRight.apply))
      else
        return None
    $.filter(e =>
      e._1.fold(
        cachedModelScorer.explicitScore,
        cachedModelScorer.explicitScore,
        cachedModelScorer.explicitScore,
      ) != e._2,
    ).toOption.listen(e => scribe.info(s"Storing <$e>"))
  }
}

private object ScoreParser {
  private val OrgPrefix = Pattern.compile("""^\** """)
}
