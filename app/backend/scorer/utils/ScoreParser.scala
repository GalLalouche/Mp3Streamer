package backend.scorer.utils

import javax.inject.Inject

import backend.recon.{Album, Artist}
import backend.scorer.{CachedModelScorer, ModelScore}
import backend.scorer.storage.ArtistScoreStorage

import scala.concurrent.{ExecutionContext, Future}
import scala.util.Try

import common.rich.func.BetterFutureInstances._
import common.rich.func.MoreSeqInstances._
import common.rich.func.MoreTraverseInstances._
import common.rich.func.ToMoreFunctorOps.toMoreFunctorOps
import common.rich.func.TuplePLenses
import scalaz.Scalaz.{eitherInstance, optionInstance, ToFunctorOps, ToMonadPlusOpsUnapply, ToTraverseOpsUnapply, ToTuple2Ops}

import common.io.FileRef
import common.rich.primitives.RichBoolean.richBoolean
import common.rich.primitives.RichEither._
import common.rich.primitives.RichString._

/** Parses the .org file generated by [[AlbumScoreToOrg]]. */
private class ScoreParser @Inject() (
    artistScoreStorage: ArtistScoreStorage,
    cachedModelScorer: CachedModelScorer,
    ec: ExecutionContext,
) {
  private implicit val iec: ExecutionContext = ec

  private def parse(line: String): Option[(Either[Artist, Album], Option[ModelScore])] = {
    val withoutPrefix = line.removeAll("^\\** ")
    // TODO use the parser here as well, using either or something.
    if ((withoutPrefix.startsWith("ARTIST") || withoutPrefix.startsWith("ALBUM")).isFalse)
      return None

    val $ : Try[(Either[Artist, Album], Option[ModelScore])] =
      if (withoutPrefix.startsWith("ARTIST"))
        ArtistScoreParser(line).map(TuplePLenses.tuple2First.modify(Left.apply))
      else
        AlbumScoreParser(line).map(TuplePLenses.tuple2First.modify(Right.apply))
    $.filter(e =>
      !(e._1
        .fold(cachedModelScorer.explicitScore, cachedModelScorer.explicitScore)
        .toModelScore == e._2),
    ).toOption
      .listen(e => scribe.info(s"Storing <$e>"))
  }
  private def store(scores: Seq[(Either[Artist, Album], ModelScore)]): Future[Unit] = {
    val (artists, albums) = scores.map(_.fold(_.eitherStrengthenLeft(_))).separate
    assert(albums.isEmpty)
    // FIXME multiple overwrite void silently fails on foreign key error
    artists.traverse(Function.tupled(artistScoreStorage.replace)).run.void
  }
  def parseFile(file: FileRef): Future[Unit] = parseLines(file.lines)
  def parseLines(lines: Seq[String]): Future[Unit] =
    store(lines.flatMap(parse).flatMap(e => e._2.map(e._1 -> _)))
}
