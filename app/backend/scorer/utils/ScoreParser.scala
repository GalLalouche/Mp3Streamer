package backend.scorer.utils

import backend.logging.Logger
import backend.recon.{Album, Artist}
import backend.scorer.{CachedModelScorer, ModelScore}
import backend.scorer.storage.ArtistScoreStorage
import javax.inject.Inject

import scala.concurrent.{ExecutionContext, Future}

import scalaz.Scalaz.{eitherInstance, optionInstance, ToFunctorOps, ToMonadPlusOpsUnapply, ToTraverseOpsUnapply, ToTuple2Ops}
import common.rich.func.BetterFutureInstances._
import common.rich.func.MoreSeqInstances._
import common.rich.func.MoreTraverseInstances._
import common.rich.func.ToMoreFunctorOps.toMoreFunctorOps
import common.rich.func.TuplePLenses

import common.io.FileRef
import common.rich.primitives.RichBoolean.richBoolean
import common.rich.primitives.RichEither._
import common.rich.primitives.RichString._

/** Parses the .org file generated by [[AlbumScoreToOrg]]. */
private class ScoreParser @Inject()(
    artistScoreStorage: ArtistScoreStorage,
    cachedModelScorer: CachedModelScorer,
    logger: Logger,
    ec: ExecutionContext,
) {
  private implicit val iec: ExecutionContext = ec

  private def parse(line: String): Option[(Either[Artist, Album], Option[ModelScore])] = {
    val withoutPrefix = line.removeAll("^\\** ")
    // TODO use the parser here as well, using either or something.
    if ((withoutPrefix.startsWith("ARTIST") || withoutPrefix.startsWith("ALBUM")).isFalse)
      return None

    val $ = if (withoutPrefix.startsWith("ARTIST"))
      ArtistScoreParser(line).map(TuplePLenses.tuple2First.modify(Left.apply))
    else
      AlbumScoreParser(line).map(TuplePLenses.tuple2First.modify(Right.apply))
    $
        .filter(e => !(e._1.fold(cachedModelScorer.apply(_), cachedModelScorer.apply(_)) contains e._2))
        .toOption
        .listen(e => logger.info(s"Storing <$e>"))
  }
  private def store(scores: Seq[(Either[Artist, Album], ModelScore)]): Future[Unit] = {
    val (artists, albums) = scores.map(_.fold(_.eitherStrengthenLeft(_))).separate
    assert(albums.isEmpty)
    // FIXME multiple overwrite void silently fails on foreign key error
    artists.traverse(Function.tupled(artistScoreStorage.replace)).run.void
  }
  def parseFile(file: FileRef): Future[Unit] = parseLines(file.lines)
  def parseLines(lines: Seq[String]): Future[Unit] =
    store(lines.flatMap(parse).flatMap(e => e._2.map(e._1 -> _)))
}
