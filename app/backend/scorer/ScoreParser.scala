package backend.scorer

import backend.logging.Logger
import backend.recon.Artist
import javax.inject.Inject

import scala.concurrent.{ExecutionContext, Future}

import common.io.FileRef
import common.rich.RichEnumeratum._
import common.rich.collections.RichTraversableOnce._
import common.rich.primitives.RichBoolean.richBoolean
import common.rich.primitives.RichString._

/** Parses the .org file generated by [[AlbumScoreToOrg]]. */
private class ScoreParser @Inject()(
    artistReconsScorer: ArtistScoreStorage,
    cachedModelScorer: CachedModelScorer,
    logger: Logger,
    ec: ExecutionContext,
) {
  private implicit val iec: ExecutionContext = ec

  private def parse(line: String): Option[(Artist, ModelScore)] = {
    val withoutPrefix = line.removeAll("^\\** ")
    if (withoutPrefix.startsWith("ARTIST").isFalse)
      return None
    val (artist, score) = withoutPrefix
        .split(" ; ")
        .ensuring(_.length == 2)(1)
        .splitParse(" === ", Artist.apply, e => ModelScore.withPrefixCaseInsensitive(e.trim).single)

    if (score == ModelScore.Default || cachedModelScorer.apply(artist).contains(score))
      return None
    logger.verbose(s"Storing <${artist.name}> with score <$score>")
    Some(artist, score)
  }
  def parseFile(file: FileRef): Future[Unit] =
    artistReconsScorer.overwriteMultipleVoid(file.lines.flatMap(parse))
}
